import{_ as a,c as t,a3 as r,o as i}from"./chunks/framework.CGQ59HuL.js";const p=JSON.parse('{"title":"Header and Data Sync","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Header and Data Sync | Rollkit"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"learn/specs/header-sync.md","filePath":"learn/specs/header-sync.md","lastUpdated":1752767714000}'),n={name:"learn/specs/header-sync.md"};function o(s,e,l,d,c,h){return i(),t("div",null,e[0]||(e[0]=[r('<h1 id="header-and-data-sync" tabindex="-1">Header and Data Sync <a class="header-anchor" href="#header-and-data-sync" aria-label="Permalink to &quot;Header and Data Sync&quot;">​</a></h1><h2 id="abstract" tabindex="-1">Abstract <a class="header-anchor" href="#abstract" aria-label="Permalink to &quot;Abstract&quot;">​</a></h2><p>The nodes in the P2P network sync headers and data using separate sync services that implement the <a href="https://github.com/celestiaorg/go-header" target="_blank" rel="noreferrer">go-header</a> interface. Rollkit uses a header/data separation architecture where headers and transaction data are synchronized independently through parallel services. Each sync service consists of several components as listed below.</p><table tabindex="0"><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody><tr><td>store</td><td>a prefixed <a href="https://github.com/ipfs/go-datastore" target="_blank" rel="noreferrer">datastore</a> where synced items are stored (<code>headerSync</code> prefix for headers, <code>dataSync</code> prefix for data)</td></tr><tr><td>subscriber</td><td>a <a href="https://github.com/libp2p/go-libp2p" target="_blank" rel="noreferrer">libp2p</a> node pubsub subscriber for the specific data type</td></tr><tr><td>P2P server</td><td>a server for handling requests between peers in the P2P network</td></tr><tr><td>exchange</td><td>a client that enables sending in/out-bound requests from/to the P2P network</td></tr><tr><td>syncer</td><td>a service for efficient synchronization. When a P2P node falls behind and wants to catch up to the latest network head via P2P network, it can use the syncer.</td></tr></tbody></table><h2 id="details" tabindex="-1">Details <a class="header-anchor" href="#details" aria-label="Permalink to &quot;Details&quot;">​</a></h2><p>Rollkit implements two separate sync services:</p><h3 id="header-sync-service" tabindex="-1">Header Sync Service <a class="header-anchor" href="#header-sync-service" aria-label="Permalink to &quot;Header Sync Service&quot;">​</a></h3><ul><li>Synchronizes <code>SignedHeader</code> structures containing block headers with signatures</li><li>Used by all node types (sequencer, full, and light)</li><li>Essential for maintaining the canonical view of the chain</li></ul><h3 id="data-sync-service" tabindex="-1">Data Sync Service <a class="header-anchor" href="#data-sync-service" aria-label="Permalink to &quot;Data Sync Service&quot;">​</a></h3><ul><li>Synchronizes <code>Data</code> structures containing transaction data</li><li>Used only by full nodes and sequencers</li><li>Light nodes do not run this service as they only need headers</li></ul><p>Both services:</p><ul><li>Utilize the generic <code>SyncService[H header.Header[H]]</code> implementation</li><li>Inherit the <code>ConnectionGater</code> from the node&#39;s P2P client for peer management</li><li>Use <code>NodeConfig.BlockTime</code> to determine outdated items during sync</li><li>Operate independently on separate P2P topics and datastores</li></ul><h3 id="consumption-of-sync-services" tabindex="-1">Consumption of Sync Services <a class="header-anchor" href="#consumption-of-sync-services" aria-label="Permalink to &quot;Consumption of Sync Services&quot;">​</a></h3><h4 id="header-sync" tabindex="-1">Header Sync <a class="header-anchor" href="#header-sync" aria-label="Permalink to &quot;Header Sync&quot;">​</a></h4><ul><li>Sequencer nodes publish signed headers to the P2P network after block creation</li><li>Full and light nodes receive and store headers for chain validation</li><li>Headers contain commitments (DataHash) that link to the corresponding data</li></ul><h4 id="data-sync" tabindex="-1">Data Sync <a class="header-anchor" href="#data-sync" aria-label="Permalink to &quot;Data Sync&quot;">​</a></h4><ul><li>Sequencer nodes publish transaction data separately from headers</li><li>Only full nodes receive and store data (light nodes skip this)</li><li>Data is linked to headers through the DataHash commitment</li></ul><h4 id="parallel-broadcasting" tabindex="-1">Parallel Broadcasting <a class="header-anchor" href="#parallel-broadcasting" aria-label="Permalink to &quot;Parallel Broadcasting&quot;">​</a></h4><p>The block manager broadcasts headers and data in parallel when publishing blocks:</p><ul><li>Headers are sent through <code>headerBroadcaster</code></li><li>Data is sent through <code>dataBroadcaster</code></li><li>This enables efficient network propagation of both components</li></ul><h2 id="assumptions" tabindex="-1">Assumptions <a class="header-anchor" href="#assumptions" aria-label="Permalink to &quot;Assumptions&quot;">​</a></h2><ul><li>Separate datastores are created with different prefixes: <ul><li>Headers: <code>headerSync</code> prefix on the main datastore</li><li>Data: <code>dataSync</code> prefix on the main datastore</li></ul></li><li>Network IDs are suffixed to distinguish services: <ul><li>Header sync: <code>{network}-headerSync</code></li><li>Data sync: <code>{network}-dataSync</code></li></ul></li><li>Chain IDs for pubsub topics are also separated: <ul><li>Headers: <code>{chainID}-headerSync</code> creates topic like <code>/gm-headerSync/header-sub/v0.0.1</code></li><li>Data: <code>{chainID}-dataSync</code> creates topic like <code>/gm-dataSync/header-sub/v0.0.1</code></li></ul></li><li>Both stores must be initialized with genesis items before starting: <ul><li>Header store needs genesis header</li><li>Data store needs genesis data (if applicable)</li></ul></li><li>Genesis items can be loaded via <code>NodeConfig.TrustedHash</code> or P2P network query</li><li>Sync services work only when connected to P2P network via <code>P2PConfig.Seeds</code></li><li>Node context is passed to all components for graceful shutdown</li><li>Headers and data are linked through DataHash but synced independently</li></ul><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h2><p>The sync service implementation can be found in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go" target="_blank" rel="noreferrer">pkg/sync/sync_service.go</a>. The generic <code>SyncService[H header.Header[H]]</code> is instantiated as:</p><ul><li><code>HeaderSyncService</code> for syncing <code>*types.SignedHeader</code></li><li><code>DataSyncService</code> for syncing <code>*types.Data</code></li></ul><p>Full nodes create and start both services, while light nodes only start the header sync service. The services are created in <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go" target="_blank" rel="noreferrer">full</a> and <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go" target="_blank" rel="noreferrer">light</a> node implementations.</p><p>The block manager integrates with both services through:</p><ul><li><code>HeaderStoreRetrieveLoop()</code> for retrieving headers from P2P</li><li><code>DataStoreRetrieveLoop()</code> for retrieving data from P2P</li><li>Separate broadcast channels for publishing headers and data</li></ul><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go" target="_blank" rel="noreferrer">Header Sync</a></p><p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go" target="_blank" rel="noreferrer">Full Node</a></p><p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go" target="_blank" rel="noreferrer">Light Node</a></p><p>[4] <a href="https://github.com/celestiaorg/go-header" target="_blank" rel="noreferrer">go-header</a></p>',33)]))}const b=a(n,[["render",o]]);export{p as __pageData,b as default};
